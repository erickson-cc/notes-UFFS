Em dispositivos não-voláteis, acesso sequencial é mais rápido que acesso randômico
buffer: porção da memória principal que armazena cópias dos blocos do disco
Organização de arquivos em HEAP: o registro é inserido em qualquer lugar que tiver espaço, facilita a escrita é dificulta a consulta
Organização de arquivos SEQUENCIAL: ordenado baseado em algum atributo chave da tupla, facilita a consulta e dificulta a escrita
Organização de arquivos em HASHING: faz-se o hashing do atributo chave, facilita a consulta e facilita a escrita
pin_count: conta o número de processos que estão acessando aquele bloco. Contador de uso da página.
dirty_bit: registra se o bloco foi modificado desde que foi retirado do disco.
a LRU é a política de troca mais usada pelos SGBDs, embora o MRU tenha ganhado no teste de acesso sequencial 1-15 x2

Índices:
Índice denso: Contém entradas com todas as chaves do arquivo de dados
Índice esparso: Contém apenas algumas das chaves do arquivo de dados que apontam para blocos com os valores
Índice primário: A chave do índice é composto por uma chave da tabela
Índice secundário: outras colunas participam da chave do índice.
Índice composto:
Procurar diferença do índice secundário e índice composto

Árvore B+
A altura da árvore dará o limite máximo de acesso ao disco.
Menor altura = log_{m/2}{(N'+1)/2} // N': menor número de chaves na árvore
Maior altura = log_{m/2}{(N+1)/2} // N: maior número de chaves na árvore
				m: ordem da árvore
os tempos de inserção e busca são os mesmos = log_m{n}

HASHING:
Linear Probe Hashing: uma tabela hashing enorme para tratar colisões.
hashing extensível: aquele que tem o global e o local
linear hashing: uma fila encadeada de buckets

Stored Procedure:
create [or replace] function <name> ([<param>])
	returns <type> as $$
	declare
	-- variables
	begin
	-- logic
	end;
	$$ language plpgsql;

select * from <name>([param]); -- chamada

CREATE OR REPLACE PROCEDURE sample(soma int)
	language plpgsql as $$
	declare
	-- variables
	begin
	-- logic
	end;
	$$;

call sample;

create function <name>()
	returns trigger as $check_stock$
	declare 
		-- variables
	begin
		-- logic
	end;
	$check_stock$ language plpgsql;

create trigger check_stock
	{before|after} {update or select or delete}
	on <table>
	for each{row|statement} execute procedure <função_trigger>;
