\documentclass[]{article}
\usepackage[ ]{indentfirst}
\usepackage{tikz}
\usetikzlibrary{automata, positioning}

\usepackage[ ]{graphicx}
\title{Revisão P1\\Linguagens Formais e Autômatos}
\author{Erickson G. Müller}
\date{}

\begin{document}
	\maketitle
	\section{Conteúdos}
		\begin{enumerate}
			\item Conceitos e linguagens: 
			\begin{itemize}
				\item Símbolo
				\item Alfabeto: conjunto de símbolos (terminais) utilizados para formar cadeias que pertencem a uma linguagem.
				\item Cadeia
				\item Sentença 
				\item Concatenação
				\item Fechamento 
				\item Sufixo
				\item Prefixo
				\item Definição formal de gramática gerativa e derivação
				\item Tipos de gramáticas
			\end{itemize}
			\item Conceitos e linguagens
				Símbolo, alfabeto, cadeia, sentença, concatenação, fechamento, sufixo, prefixo. Definição
		\end{enumerate}
	\section{Teoria de Linguagens}
		\begin{itemize}
			\item Símbolo: qualidade e precedência
			\item Cadeia
			\item Tamanho de cadeia (caso cadeia vazia ($\epsilon$) )%símbolo grego
			\item prefixo (próprio)
			\item sufixo (próprio)
			\item concatenação
			\item fechamento
			\begin{enumerate}
				\item V*
				\item V+ = V* - {EE}
			\end{enumerate}
			\item linguagem finita
			\item linguagem infinita
			\item Reconhecedor: busca identificar se a sentença(ou cadeia, dependendo da apostila vs professor) pertence à linguagem ou não.
			\item sistema gerativo (gramática gerativa)

		\end{itemize}
		Computabilidade; Algoritmos e decibilidade; Soluções algoritmica decidíveis e indecidíveis. Processadores de linguagens (tradutores e interpretadores).
		
		Para problemas computáveis podemos construir uma solução algoritmica que poderá ou não ter um resultado. Caso esse algoritmo não tenha um retorno, será considerado um algoritmo indecidível.
		
		Esse conjunto de cadeias pode ser formado pela concatenação de símbolos que pertence ao alfabeto da linguagem.
		
		Os processadores de linguagem verificam se a cadeia de símbolos \textbf{pertence} à linguagem. Os processadores de linguagens são soluções algoritmicas para \textbf{problemas decidíveis}. São divididos em tradutores e interpretadores.
		
		Símbolos não têm significado intrínsico, a diferença entre eles é pela sua representação gráfica. O símbolo estará sob regras de substituição.
		
		Os processadores de linguagens podem fazer transformações de linguagens de mesmo nível, podem passar de uma linguagem de código de uma máquina para outra máquina.
		
		Tradutores recebem uma entrada chamada de fonte, fazem o processamento e resultam um objeto.
%		\begin{tikzpicture}
%			\node (processo) [draw, ellipse] {processamento};
%			\node (fonte) [left=of processo] {fonte};
%			\node (objeto) [right=of processo] {objeto};
%			\draw [->] (fonte) -- (processo);
%			\draw [->] (processo) -- (objeto);
%		\end{tikzpicture}

		Nem todas as cadeias do fechamento do alfabeto são sentenças, todas as sentenças pertencem ao fechamento do alfabeto
		
		\textbf{Gramática:} Conjunto de regras que descreve como as cadeias podem ser montadas e quando elas são válidas.
		
		Sentença é toda cadeia de símbolos que pertence à linguagem.
		
		Aplicando as regras da gramática, teremos sempre uma \textit{cadeia ou sentença} %não sei qual dos dois
		\begin{center}
		\begin{tikzpicture}[node distance=0.8cm, auto]
\tikzstyle{bloco} = [rectangle, rounded corners, minimum width=5.5cm, minimum height=0.6cm,text centered, draw=black]
\tikzstyle{seta} = [thick,->,>=stealth]

\node [bloco] (lexica) {Análise Léxica};
\node [bloco, below of=lexica] (um) {Análise Sintática};
\node [bloco, below of=um] (dois) {Análise Semântica};
\node [bloco, below of=dois] (tres) {Geração de Código Intermediário};
\node [bloco, below of=tres] (quatro) {Otimização};

\draw [seta] (lexica) -- (um);
\draw [seta] (um) -- (dois);
\draw [seta] (dois) -- (tres);
\draw [seta] (tres) -- (quatro);

\end{tikzpicture}
\end{center}

		Análise léxica faz o tratamento de erros, reconhecimento do tipo da variável através do identificador

		Faz parte da saída da análise léxica uma estrutura chamada de fita que pertence o identificador dos tokens, essa fita é a entrada da análise sintática. O final dessa fita é um símbolo de final de sentença. 

		Análise sintática faz a análise da sentença  usando o identificadores das cadeias que foram validadas na análise léxica. A sentença é avaliada através da concatenação de identificadores em uma determinada ordem.
		
		A análise semântica verifica  o tipo dos siímbolos e como estão sendo utilizados.
		
		A geração de Código intermediário passa a sentença para código assembly.
		
		Concatenação de símbolos de um alfabeto de uma linguagem, essa concatenação vai formar cadeias. Essas cadeias podem ser sentenças ou não. Caso a cadeia pertença à linguagem, é considerado uma sentença.
		
		Fechamento do alfabeto de uma linguagem é a concatenação dos símbolos do alfabeto em qualquer ordem e em qualquer quantidade.
		
		\begin{center}
			\includegraphics[scale=0.09]{images/aula-1.png}		
		\end{center}
		\subsection{Definição Formal da Gramática}
			\begin{enumerate}
				\item N: o conjunto de não terminais, ou variáveis.
				\item T: é o conjunto de terminais, ou alfabeto. Sendo que N e T são conjuntos distintos.
				\item P: é o conjunto distinto de produções, ou regras. \\ Sendo que:
				$P \subset (N \cup T)^{+} . (N \cup T)^{*}$
				\item S: é o símbolo não terminal que será o \textbf{símbolo inicial} de uma sentença %$S \to A \to \B \to C$...
			\end{enumerate}
	\section{Definição formal de gramática gerativa e derivação}
		A única operação da gramática gerativa é a \textbf{substituição}.
	\section{Análise Sintática}
	Uma estrutura sintática de uma \textbf{gramática} é determinada dessa maneira:
	$$<S> ::= <artigo><substantivo><verbo>$$
	$<artigo> ::= a$\\
	$<substantivo> ::= casa | coisa | lua$\\
	$<verbo> ::= caiu | saiu$\\
	
	Formalismo de Backus-Naur:
	\begin{itemize}
		\item $<substantivo> ::= casa$
		\item $<substantivo> ::= coisa$
		\item $<substantivo> ::= lua$
		\item $<verbo> ::= caiu$
		\item $<verbo> ::= saiu$
		\item $<artigo> ::= a$
	\end{itemize}
	Em seguida, temos a seguinte \textbf{produção}:\\
	$<S> \to <artigo><substantivo><verbo>$\\
	$<S>\to a <substantivo> <verbo>$\\
	$<S> \to a - casa<verbo>$\\
	$<S> \to a - casa- caiu$\\
	
	\newpage
	Exercício: 

	Altere a gramática acima para que possa acrescentar as seguintes frases:
	\begin{enumerate}
		\item o cão saiu
		\item o cofre fechou
		\item o gato saiu
		\item o gato caiu
	\end{enumerate}
	
		$$<S> ::= <artigo><substantivo><verbo>$$
	$<artigo> ::= a | o$\\
	$<substantivo> ::= casa | coisa | lua | cao | cofre | gato $\\
	$<verbo> ::= caiu | saiu | fechou$\\
	
	Correção:\\
	$ <S> ::= o<A>$\\
	$<A> ::= gato<B> | cao <C> | cofre <D>$\\
	$<B> ::= <C> | caiu$\\
%	$<B> ::= saiu | caiu$
	$<C> ::= saiu$\\
	$<D> ::= fechou$\\
	
%	\newpage
%	Exercício 2:\\
%	Considerando a gramática
%	$S::= o<A> | a<S2>$\\
%	$<A>::= gato<B> | cao <C> | cofre <D>$\\
%	$<B>::=<C>| caiu$\\
%	$<C>::=saiu$\\
%	$<D> ::= fechou$\\
%	$<S2> ::= <SUBS><VERBO>$\\
%	$<SUBS> ::= casa|coisa|lua$\\
%	$<VERBO>::= caiu|saiu$\\
%	
%	Altere a gramática para incluir as seguintes sentenças:
%	\begin{enumerate}
%		\item a casa fechou
%		\item o cofre caiu
%		\item o cofre saiu
%		\item o cão caiu
%		\item a lua saiu
%		\item a lua caiu
%		\item a coisa saiu
%		\item a coisa caiu
%		\item a casa saiu
%		\item a casa caiu
%		\item o cão saiu
%		\item o cofre fechou
%		\item o gato saiu
%		\item o gato caiu
%	\end{enumerate}
%		$S::= o<A> | a<S2>$\\
%	$<A>::= gato<B> | cao <W> | cofre <D>$\\
%	$<B>::=<C>| <X>$\\
%	$<W>::= <C>|<X>$
%	$<C>::=saiu$\\
%	$<X> ::= caiu$\\
%	$<Y>::= fechou$\\
%	$<D> ::= <C>| <Y>|<X>$\\
%	$<S2> ::= <SUBS><VERBO>$\\
%	$<SUBS> ::= casa|coisa|lua$\\
%	$<VERBO>::= <X>|<C>|<D>$\\
		\subsection{Derivação}
			Se $a \to b$, então a \textbf{produz} b\\
			se $a\to b\to c \to$...$\to z$ então $a \to ^* z$ e a produz z pelo \textbf{fecho derivativo}\\
			Então $a\to ^0 a$\\
			$a\to ^1 b$ se $a\to b$\\
%			$a \to ^{n+1} z$ se $a \to^n y e$
	\section{Hierarquia de Chomsky}
	\includegraphics[scale=0.7]{images/Hierarquia_de_Chomsky.png}
	
	Linguagens de tipo 3 (regulares) são resolvidas por gramáticas regulares
	
	O formalismo que resolve problemas de linguagens regulares é o \textbf{autômato finito}
	
	Linguagens do tipo 2 são resolvidas por gramáticas livre de contexto
	
	O formalismo que resolve é o \textbf{autômato de pilha}
	
	Gramáticas livre de contexto resolvem problemas do tipo 2 e do tipo 3.
	
	Linguages do tipo 1 são linguagens sensíveis ao contexto e são resolvitos por gramáticas irrestritas.
	
	\textbf{Máquinas irrestritas} resolvem problemas de linguagens do tipo 0 e do tipo 1.
	
	\subsection{Gramáticas Regulares (tipo 3)}
		Tem 3 formatos de produção possíveis, que é um não terminal que define o nome da regra e as produções podem ser nos formatos:\\
		$A::= a | aA| \epsilon$
	\subsection{Gramáticas Livres de Contexto}
		$A::=(N\cup T)^*$
	\subsection{Gramáticas Sensíveis ao Contexto}
		%Podemos definir o N que dá nome à regra não apenas como u
		Não inclui o Epsilon, portanto o menor tamanho das produções é 1\\
		$ (N \cup T)^{+}::= (N \cup T)^*$, sendo que $ |(N \cup T)^{+}| \leq |(N \cup T)^*|$.
		% o menor igual não se aplica na regra $<S>$. Ou seja, $<S> ::= \epsilon$
		
		A exceção à comparação dos tamanhos é quando. $<S> ::= \epsilon$

		
		$<S>$ não pode aparecer no lado direito de $P$.
		
	\subsection{Gramáticas Irrestritas}
		Não há restrição nenhuma, logo pode ser formado por qualquer concatenação:
		
		$(N\cup T)^+ ::= (N\cup T)^*$
	\section{Exemplos}
		$L(g) = \{ x | x \in (0,1)^*$, onde o número de ocorrências de $1$ é ímpar$\}$
		\begin{itemize}
		
			
			
			\item Considerando que $A::= a|aA|\epsilon$
			
			%\item Regra:
			
			\item $<S>::= 0<S> | 1<A>$ nessa regra o número de ocorrências de 1 é par., portanto estamos na iminência de substituir o  S por uma de suas produções.
		
			\item $A::= 0<A>|1<S>|\epsilon$ criamos essa regra para poder encerrar a frase. O S é chamado para impedir que o número de ocorrências do símbolo 1 seja par.
		\end{itemize}
		
		Agora,
		
		$L(g) = \{ x | x \in (0,1)^{+}$, onde o número de ocorrências de $1$ é par$\}$
		\begin{itemize}
		
			
			\item Considerando que $A::= a|aA|\epsilon$
			
			%\item Regra:
			
			\item $<S>::= 0<B> | 1<A>$ Tamanho da cadeia maior que 0
		
			\item $A::= 0<A>|1<B>$ 
			
			\item $B ::= 0 <B>| 1<A>| \epsilon$
		\end{itemize}
		
		Outro,
		
		$L(g) = \{ x | x \in (0,1)^{+}$, onde o número de ocorrências de $0$ é ímpar e $1$ é par$\}$
		\begin{itemize}
			\item Considerando que $A::= a | aA | \epsilon$
			
%			\item $<S>::= 0 <C>|1<B>$
			
			\item $<S> ::= 0<C>|1<B>$ Se 0 for par e 1 for par.
			\item $<B> ::= 0 <D> | 1<S>$ Se 0 for par e 1 for ímpar.
			\item $<C> ::= 0 <S> | 1<D> | \epsilon$ Se 0 for ímpar e 1 for par.
			\item $<D> ::= 0 <B> | 1<C>$ Se 0 for ímpar e 1 for ímpar.
			
		\end{itemize}
		\newpage
		Outro,
		
		$L(g) = \{ x | x \in (0,1)^{+}$, onde $|x|$ é par se x inicia por 0, senão $|x|$ é ímpar$\}$
		\begin{itemize}
			\item $<S>::= 0<A>|1<C>$ Inicial
			\item $<A>::= 0<B>|1<B>$ Se inicia por 0 e $|x|$ é ímpar
			\item $<B>::= 0<A>|1<A>|\epsilon$ Se inicia por 0 e $|x|$ é par
			\item $<C>::= 0<D>|1<D>$ se inicia por 1 e $|x|$ é par
			\item $<D>::= 0<C>|1<C>|\epsilon$ se inicia por 1 e $|x|$ é ímpar
%			\item $<>::= 0<>|1<>$
		\end{itemize}
		Correção do professor
		
		\begin{itemize}
			\item $<S>::= 0<A>|1<B>$ Inicial
			\item $<A>::= 0<B>|1<B>$ Se inicia por 0 e $|x|$ é ímpar ou se inicia por 1 e $|x|$ é par.
			\item $<B>::= 0<A>|1<A>|\epsilon$ Se inicia por 0 e $|x|$ é par ou se inicia por 1 e $|x|$ é ímpar.
		\end{itemize}
		Outro,
		
		$L(g) = \{ x | x \in (a,b,c)^{+}$, onde $|a|+|c|$ é par se $x$ inicia por $b$, senão $|b|$ é ímpar. $x$ não possui $c$ concatenados. $\}$

		\begin{itemize}
			\item $<S>::= a<D> | b<A> | c<E> $ Inicial
			\item $<A>::= a<B> | b<A> | c<C> | \epsilon$ se x inicia por \textbf{b} e $c+a$ é \textbf{par} e a anterior não é \textbf{c}.
			\item $<B>::= a<A> | b<B> | c<C> $ se x inicia por \textbf{b} e $c+a$ é \textbf{ímpar} e a anterior não é \textbf{c}.
			\item $<C>::= a<B> | b<C> | \epsilon $ se x inicia por \textbf{b} e $c+a$ é \textbf{par} e a anterior é \textbf{c}.
			\item $<>::= $ se x não inicia por \textbf{b} e $|b|$ é \textbf{ímpar}
			\item $<D>::= a<D> | b<> | c<> $ se x não inicia por \textbf{b} e $|b|$ é \textbf{par} e a anterior não é c
			\item $<D>::= a<D> | b<> $ se x não inicia por \textbf{b} e $|b|$ é \textbf{par} e a anterior é c
		\end{itemize}
		
		Correção do professor:
		
		\begin{itemize}
			\item $S::= a<E> | b<A> | c<F>$
			\item $A::= a<B> | b<A> |c<c>| \epsilon$ a+c é par e !c
			\item $B::= a<A> |b<B> |c<D>$
			\item
			% S > b A
			% S > b a
			% S > b b
			% S > b c
			% S > b \epsilon
				% sabemos que A::= a|b|c|\epsilon
			% S > b a 
			% S > b a a
			% S > b a b
			% S > b a c
			% S > b a B
				% B::=a|b|c
			% S > b c 
			% S > b c a
			% S > b c b
			% S > b c c NÃO PODE
			% S > b c C
				% portanto C ::= a|b
			% S > b a c
			% S > b a a B
			% S > b a a a
			% S > b a a b
			% S > b a a c
			% S > b a a \epsilon

			% S > b a b (a,b,c)
			% S > b a c (a,b,\epsilon)
				%D::= a|b|\epsilon
			% S > b c a (a,b,c\epsilon)
				%portanto C::= a<A> | b
			% S > b c b (a, b, c)
				% portanto C::= a<A> | b<B>



			% S > b A
			% S > b a B
			% S > b a c D
			% S > b a c b (a,b,c,\epsilon)
			% S > b a c b A
				

				% criar a regra E
				% S > a E
				% S > a (a,b,c)
				% S > a a (a,b,c)
				% portanto E::= a<E>|b|c
				% S > a b (a,b,c,\epsilon)

				% criar a regra F
				% F::=a|b|c|\epsilon
				% S > a b F
				% S > a b (a,b,c,\epsilon)
				% F::=a<F>|b|c|\epsilon
				% S > a c (a,b)
				% criar a regra G
				% G::=a|b
				% S> a c a (a,b,c)
				% portanto G::= a<E>|b
				% S> a c b (a,b,c,\epsilon)
				% portanto G::= a<E>|b<F>


				% S > a c b c a (a,b,c,\epsilon)
				% portanto H::= a<F> | b | \epsilon
				% S > a c b c b (a,b,c)
				% portanto H::= a<F>|b<E>|\epsilon

				% se começa com C
				% S > c (a,b,\epsilon)
				% portanto S::= a<E> | b<A> | c<G>

		\end{itemize}
	\section{Autômato Finito}
		Reconhecimento de padrões em processamento de texto (cadeias).
%		\begin{tikzpicture}
%			\node (on) [draw, ellipse] {on};
%			\node (off) [left=of on] {off};
%			\node (on) [right=of off] {off};
%			\draw [->] (on) -- (off);
%			\draw [->] (processo) -- (objeto);
%		\end{tikzpicture}

		\includegraphics[scale=0.6]{images/AFD-interruptor.png}		
		
		Podem ser determinísticos ou não determinísticos.
		
		Se $w \in L$
		\begin{itemize}
			\item AFD
			\item AFND
		\end{itemize}
		
		Definição formal		
		\begin{itemize}
			\item $K \to$ conjunto de estados.
			\item $\Sigma \to$ alfabeto da linguagem.
			\item $\delta \to \kappa _x \Sigma \to \kappa$.
			\item $q_o \to \in \kappa$ estado inicial.
			\item $F \to $ estado final.
		\end{itemize}
		
		Determinismo: $\delta(q,a) \to p$
		
		Indeterminismo: $\delta(q,a) \to p | r | s$
		
		$$\kappa _x \Sigma \to \kappa$$
		
		Estado |$^\Sigma$ Transição \textit{a transição é rotulada por um símbolo do alfabeto da linguagem}
		
		$\alpha \in L$ se $\delta (q_o, \alpha) \to^* p \wedge p \in F$ Alcançamos um estado $p$ e esse estado é final.
		
		$L(AF) = \{ \alpha | \delta(q,\alpha) \to p \wedge p \in F\}$
		\subsection{exemplo}		
		$L(G) =\{ \alpha | \alpha \in (a,b)^+$ onde números de $a$'s é ímpar$\}$
		
		$S::= a<A> | b<S> | a$ % podemos encerrar no S
		
		$A::= a<S> | b<A> |\varepsilon$
		
		\subsection{Diagrama de transição e Tabela de transição}
		Considerando a gramática $L(G) =\{ \alpha | \alpha \in (a,b)^+$ onde números de $a$'s é ímpar$\}$
		
\begin{tikzpicture}[node distance=2cm, on grid, auto]
    % Define os nós com a opção 'state' para circulá-los
    \node[state] (S) {S};
    \node[state, right of=S] (A) {A};
    \node[state, left of = S] (C) {C};

    % Adiciona a transição de S para A
    \path[->] (S) edge node {} (A);
    \path[->] (S) edge node {} (C);
    \path[->] (S) edge node {} (S);
\end{tikzpicture}

		\includegraphics[scale=0.7]{images/AFD-tabular-grafica.png}
		
		no estado $q^2$, quando for $1$ o tracinho significa que é um $\varepsilon$
		\subsection{Expressões regulares}
		
		$(0,1)^*$
		
		Cadeias que terminam por 01
		$$(0+1)^*.0.1$$
		
		Cadeias com exatamente 2 $0$'s
		$$1^*01^*01^*$$
		
		Cadeias com tamanho par
		$$((0+1)(0+1))^*$$		
		
		
		Cadeias com tamanho ímpar
		$$(0+1)((0+1)(0+1))^*$$
		
		\subsection{Eliminação de epsilon Transições}
		
		$A::= 0<A> | \varepsilon <B>$
		
		$B::= 1<B> | \varepsilon<C>$
		
		$C::= 2<C> | \varepsilon$
		
		\includegraphics[scale=0.24]{images/eliminacao-de-transicoes.png}
		
		Conjuntos das produções
		
		$A=\{ A,B,C\}$
		
		$B=\{B,C\}$
		
		$C=\{C\}$
				
		$A ::= 0<A> | 1<B> | 2<C> | \varepsilon$
		
		$B::= 1<B> | 2<C> | \varepsilon$
		
		$C::= 2<C> | \varepsilon$
		
		\includegraphics[scale=0.24]{images/eliminadas-transicoes.png}
		
		\subsection{Transformação de AFND para AFD}
		
		$S::= 0<S> | 1<A> | A$
		
		$A::= 0<C> | B$
		
		$B::= 1<B> | 0<A> | 0$
		
		$C::= 1<A> | B$
		
		\begin{center}
		Identificar os $\varepsilon$
		\end{center}
		
		$S::= 0<S> | 1<A> | \varepsilon<A>$
		
		$A::= 0<C> | \varepsilon <B>$
		
		$B::= 1<B> | 0<A> | 0$
		
		$C::= 1<A> | \varepsilon<B>$
		
		\begin{center}
		Eliminar
		\end{center}
		
		%$S::= 0<S> | 1<A> | 0 <C> | B$
		$S::= 0<S> | 1<A> | 0<C> |1<B> | 0 <A> | \varepsilon$
		
		$A::= 0<C> | 1<B> | 0 <A> | \varepsilon$
		
		$B::= 1<B> | 0 <A> | \varepsilon$
		
		$C::= 1<A> | 1<B> | 0<A> | \varepsilon$
		
\end{document}
