-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_JK_FF is
  generic (Default : std_logic);  
  port (
    Q: out std_logic;
    notQ: out std_logic;
    J: in std_logic;
    C: in std_logic;
    K: in std_logic );
end DIG_JK_FF;

architecture Behavioral of DIG_JK_FF is
  signal temp: std_logic := Default;
begin
  process (C)
  begin
    if rising_edge(C) then
      if (J='0' and K='1') then
         temp <= '0';
      elsif (J='1' and K='0') then
         temp <= '1';
      elsif (J='1' and K='1') then
         temp <= not (temp);
      end if;
    end if;
  end process;
  Q <= temp;
  notQ <= NOT( temp );
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    CLOCK: in std_logic;
    B1: out std_logic;
    B2: out std_logic;
    B3: out std_logic;
    B0: out std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic;
  signal s1: std_logic;
  signal B0_temp: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal B1_temp: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic;
  signal B2_temp: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal B3_temp: std_logic;
  signal s11: std_logic;
begin
  gate0: entity work.DIG_JK_FF -- Q0
    generic map (
      Default => '0')
    port map (
      J => s0,
      C => CLOCK,
      K => s1,
      Q => B0_temp,
      notQ => s2);
  gate1: entity work.DIG_JK_FF -- Q1
    generic map (
      Default => '0')
    port map (
      J => s3,
      C => CLOCK,
      K => s4,
      Q => B1_temp,
      notQ => s5);
  gate2: entity work.DIG_JK_FF -- Q2
    generic map (
      Default => '0')
    port map (
      J => s6,
      C => CLOCK,
      K => s7,
      Q => B2_temp,
      notQ => s8);
  gate3: entity work.DIG_JK_FF -- Q3
    generic map (
      Default => '0')
    port map (
      J => s9,
      C => CLOCK,
      K => s10,
      Q => B3_temp,
      notQ => s11);
  s9 <= (B2_temp AND s2 AND s5);
  s10 <= (s2 AND s5 AND s8);
  s6 <= (B1_temp AND s2 AND s11);
  s7 <= (B3_temp AND B1_temp AND s2);
  s3 <= (B0_temp AND NOT (B3_temp XOR B2_temp));
  s4 <= (B0_temp AND (B3_temp XOR B2_temp));
  s0 <= ((B2_temp AND (B3_temp XOR B1_temp)) OR (NOT (B3_temp XOR B1_temp) AND s8));
  s1 <= ((NOT (B1_temp XOR B2_temp) AND B3_temp) OR (s11 AND (B1_temp XOR B2_temp)));
  B1 <= B1_temp;
  B2 <= B2_temp;
  B3 <= B3_temp;
  B0 <= B0_temp;
end Behavioral;
