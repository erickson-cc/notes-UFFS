\documentclass{article}
\usepackage[]{amsmath}
%\usepackage[]{pxfonts}
\usepackage[english]{babel}

\title{Revisão Prova 1 de\\Organização de Computadores\\Luciano L. Caimi}
\author{Erickson Giesel Müller}
\date{}

\begin{document}
	\maketitle
	\section*{Conteúdos}
		\begin{enumerate}
			\item Arquitetura Von Neumann
			\item Arquitetura Harvard
			\item Arquitetura RISC
			\item Arquitetura CISC
			
			\item Pipeline
			\item Hierarquia de memória
				\begin{enumerate}
				 	\item Cache
				 	\item Memória Principal RAM
				 	\item Memória Virtual
				 	\item Armazenamento de Massa
				\end{enumerate}
		\end{enumerate}
	\section{Introdução}
		Ao se descreverem computadores, é comum se fazer uma distinção entre \textit{arquitetura} e \textit{organização} de computadores. A arquitetura se refere aos atributos de um sistema \textbf{visíveis ao programador}, em outras palavras, são os atributos que possuem um impacto direto sobre a execução lógica de um programa, representada pela arquitetura de conjunto de instrução (ISA). a organização de computadores refere-se às unidades operacionais e suas interconexões que percebam as especificações de arquitetura, como sinais de controole, interface entre o computador e periféricos e a tecnologia de memória utilizada.
	\section{Arquitetura Multinível}
		O Sistema Operacional é a camada mais baixa na parte de softwares de um computador, pois traduz as linguagens para a linguagem de máquina.
		
	\section{Arquitetura CISC}
		A arquitetura CISC apresenta instruções complexas que demandam um \textbf	{grande número de ciclos} para serem executadas. Dezenas de modos de endereçamento, instruções de tamanhos variados e referência a operandos na memória principal.\\
		Nas arquiteturas CISC fica mais difícil implementar o pipeline. A unidade de controle é microprogramada. Menos instruções por ciclo.
		
	\section{Arquitetura RISC}
		Instruções mais simples, demandando u mnúmero \textbf{fixo} de ciclos de máquina para a sua execução. Uso de poucos e simples modos de endereçamento. Poucos formatos de instruções.\\
		Apenas instruções de load/store referenciam operandos na memória principal. Cada fase de processamento da instrução tem a duração fixa igual a um ciclo de máquina. O formato fixo das instruções facilita o pipeline. As instruções são executadas, na sua maioria, em apenas um ciclo de máquina.\\
		A unidade de controle é em geral hardwired, ou seja, não há microprograma para interpretar as instruções. Arquitetura orientada a registrador, todas as operações aritiméticas são realizadas entre registradores.\\
		A desvantagem de usar uma arquitetura com um único ciclo é que o ciclo do clock se torna ineficiente, pois este deve ser do tamanho da instrução mais lenta. Isso é um grande problema quando se considera instruções mais complexas como por exemplo multiplicação de ponto flutuante.
	
	\section{Pipeline}
	\section{Memória Cache}
		\subsection{Cache com Mapeamento Direto}
			Para calcular a linha da memória cache:
			$$i = j \mod m$$
			onde:\\
			$i$ é o número da linha na memória cache\\
			$j$ é o número de blocos na memória RAM\\
			$m$ é o número de blocos na memória cache\\
			Todas as relações de endereço são em potência de 2. Assim, conseguimos encontrar a linha na memória cache, mas, em uma operação de busca, ainda precisamos saber em qual \underline{bloco} está a informação, para isso usamos duas informações de controle:			
		\subsection{Bit de Válido}
			Indica se a entrada do cache está escrita com alguma informação.
		\subsection{Bit de Tag}
			Complementa o cálculo de endereço com a sintaxe $[tag]j \mod m$. Os bits de tag informam em qual parte da memória cache está a informação de acordo com a linha calculada.
		\subsection{Melhorias na Tecnologia de Semicondutores}
			\subsection{Lei de Moore}
				A cada nó tecnológico, a largura do canal do transistor diminui, mantendo o mesmo custo de fabricação, tornando o processador mais eficiente por área. Portanto, o tamanho do transistor diminui, a quantidade de transistores aumentam e a frequência do clock acelera.\\
				Devido a isso, surgiu o problema do \textit{powerwall}, os processadores começaram a esquentar mais e precisou surgir métodos de dissipar a frequência do processador.	
	\section{Arquitetura de Von Neumann}
		Von Neumann apresenta \textbf{4 proposições}:
		\begin{itemize}
			\item Unidades Funcionais
			\begin{itemize}
				\item CPU - Unidade de Controle + ULA + Registradores
				\item Memória Principal - Instruções e Dados
				\item Dispositivo de Entrada e Saída
			\end{itemize}
			\item Aritmética Binária
			\item Ciclo de Instrução Repetitivo
			\item Programa Armazenado em Memória			
		\end{itemize}
		\subsection{Ciclo de Instrução}
			\begin{enumerate}
				\item Buscar a instrução na Memória Principal (FI - \textit{fetch instruction})
				\item Decodificar a Instrução (DI - \textit{decode instruction})
				\item Calcular os Operandos (CO)
				\item Buscar Operandos da Instrução (FO - \textit{fetch operands})
				\item Executar Instrução (EI)
				\item Armazena o Resultado (WO - \textit{write operands}
			\end{enumerate}
		\textbf{Gargalo da Arquitetura de Von Neumann:} Como a aquitetura apresenta uma memória que armazena tanto os dados quanto as instruções. O ciclo de instrução não pode fazer o FI e o FO ao mesmo tempo.\\
		Para solucionar o gargalo, os dados e as instruções saem da memória principal para o barramento de dados e vão para a cache L1 seguindo a seguinte ordem:
		$$MP \to L3 \to L2 \to L1$$
%		\textit{A cache L1 é a única que separa dados e instruções}
	\section{Arquitetura do Conjunto de Instruções}
	\section{Arquitetura do Tipo Pilha}
		Diferente das outras arquiteturas, ao retirar um valor dos registradores e encaminhar para a ULA (pop), os valores do topo da pilha são removidos. Em outras arquiteturas, uma operação \textit{mv rd, rs} copia o dado do registrador de origem para o registrador de destino (\textit{addi rd, rs, 0}).
	\section{Chamadas de Sistema (ecall)}
	\section{Chamadas de Função (call/jal)}
	\section{Manipulação de Vetores e Matrizes}
\end{document} 